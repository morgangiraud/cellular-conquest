
The goal is to design an interactive web application that hosts a strategy game based on the principles of cellular automata. The game combines elements of strategy, territory control, and the biological theory of life as outlined by John Conway's Game of Life.

The game mechanics are as follows:

1. The game accommodates two players, referred to as Player A and Player B.
2. Each cell in the game can exist in one of three states: empty, occupied by Player A (marked as 'a'), or occupied by Player B (marked as 'b').
3. The transitions of the cells follow the rules of Conway's Game of Life, where 'a' and 'b' represent live cells. When a new cell is born, its type is determined by the majority of its neighboring cells.
4. The game grid is divided into two territories, each serving as the 'country' for one player. Within each country, there is a designated area known as the 'fortress'.
5. Each turn, both players are allowed to modify the state of up to three cells within their respective countries. After these modifications, the game evolves naturally for 100 iterations according to the rules of cellular automata.
6. The ultimate objective is to infiltrate the opponent's fortress. The first player to successfully place a cell within the fortress of the opposing player is declared the winner.

Enclosed in ------[]------ is the current state of the app written in typescript using the NextJs framework and tailwindcss:

------[]------

next.config.js
```
/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = nextConfig
```

---

tailwind.config.js
```
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      backgroundColor: {
        "cell-a": "#0000FF", // blue color for player a
        "cell-b": "#FF0000", // red color for player b
        "cell-empty": "#FFFFFF", // white color for empty cells
        "cell-fortress": "#808080", // grey color for fortress cells
      },
    },
  },
  plugins: [require("@tailwindcss/aspect-ratio")],
};
```

---

src/app/globals.css
```
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --foreground-rgb: 0, 0, 0;
  --background-start-rgb: 214, 219, 220;
  --background-end-rgb: 255, 255, 255;
}

@media (prefers-color-scheme: dark) {
  :root {
    --foreground-rgb: 255, 255, 255;
    --background-start-rgb: 0, 0, 0;
    --background-end-rgb: 0, 0, 0;
  }
}

body {
  color: rgb(var(--foreground-rgb));
  background: linear-gradient(
      to bottom,
      transparent,
      rgb(var(--background-end-rgb))
    )
    rgb(var(--background-start-rgb));
}
```

---

src/app/layout.tsx
```
import "./globals.css";
import { Inter } from "next/font/google";

import { GameContextProvider } from "@/GameContext";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "CeluMata",
  description: "Strategic cellular automata game for two players",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <GameContextProvider>
      <html lang="en">
        <body className={inter.className}>{children}</body>
      </html>
    </GameContextProvider>
  );
}
```

---

src/GameContext.tsx
```
"use client";

import React, { createContext, useState, useEffect, useCallback } from "react";
import { CellState, Fortress, GameState, Player } from "./constants";
import { Game } from "./engine";

export type SelectedCellsCounterType = Record<Player, number>;

interface GameContextProps {
  size: number;
  gameState: GameState | undefined;
  player: Player | undefined;
  cells: CellState[][] | undefined;
  selectedCellsCounter: SelectedCellsCounterType;
  statusText: string;
  setPlayer: React.Dispatch<React.SetStateAction<Player | undefined>>;
  setSelectedCellsCounter: React.Dispatch<
    React.SetStateAction<SelectedCellsCounterType>
  >;
  handleCellClick: (i: number, j: number) => boolean;
  handleValidation: () => void;
}

export const GameContext = createContext<GameContextProps | undefined>(
  undefined
);

export const GameContextProvider = ({
  children,
}: {
  children: React.ReactNode;
}) => {
  const size = 8;
  const nbIter = 10;

  const [game, setGame] = useState<Game | undefined>(undefined);
  const [gameState, setGameState] = useState<GameState | undefined>(undefined);
  const [player, setPlayer] = useState<Player | undefined>(undefined);
  const [selectedCellsCounter, setSelectedCellsCounter] =
    useState<SelectedCellsCounterType>({
      a: 0,
      b: 0,
    });
  const [cells, setCells] = useState<CellState[][] | undefined>(undefined);

  const [statusText, setStatusText] = useState("");

  // Initialize the board
  useEffect(() => {
    const fortress: Fortress = {
      a: { x: size / 2, y: 1, width: 1, height: 1 },
      b: { x: size / 2, y: size - 1, width: 1, height: 1 },
    };
    const game = new Game(size, fortress);

    setGame(game);
    setPlayer(game.initialPlayer);
    setCells(game.getCellStates());
    setGameState(
      game.initialPlayer === CellState.A
        ? GameState.PLAYER_A
        : GameState.PLAYER_B
    );
  }, []);

  useEffect(() => {
    if (player === undefined) return;

    setStatusText(`Waiting for player ${player} to choose their squares`);
  }, [player]);

  const handleCellClick = useCallback(
    (i: number, j: number) => {
      if (player === undefined) return false;
      if (cells === undefined) return false;

      console.log(`handleCellClick: ${i}, ${j}`);

      let maximumReached = false;
      const newCells = [...cells];
      if (newCells[i][j] === player) {
        newCells[i][j] = CellState.EMPTY;
        setSelectedCellsCounter({
          ...selectedCellsCounter,
          [player]: selectedCellsCounter[player] - 1,
        });
      } else if (selectedCellsCounter[player] < 3) {
        newCells[i][j] = player;
        setSelectedCellsCounter({
          ...selectedCellsCounter,
          [player]: selectedCellsCounter[player] + 1,
        });
      } else {
        maximumReached = true;
      }
      setCells(newCells);

      return maximumReached;
    },
    [player, cells, selectedCellsCounter]
  );

  const handleValidation = useCallback(() => {
    if (game === undefined) return;
    if (cells === undefined) return;
    if (player === undefined) return;

    game.grid.assignCells(cells);

    setSelectedCellsCounter((prevState) => ({
      ...prevState,
      [player]: 0,
    }));

    setPlayer(player === CellState.A ? CellState.B : CellState.A);
    if (
      gameState === GameState.PLAYER_A &&
      game.initialPlayer === CellState.A
    ) {
      setPlayer(CellState.B);
      setGameState(GameState.PLAYER_B);
    } else if (
      gameState === GameState.PLAYER_A &&
      game.initialPlayer === CellState.B
    ) {
      setPlayer(undefined);
      setGameState(GameState.GAME_OF_LIFE);
    } else if (
      gameState === GameState.PLAYER_B &&
      game.initialPlayer === CellState.B
    ) {
      setPlayer(CellState.A);
      setGameState(GameState.PLAYER_A);
    } else if (
      gameState === GameState.PLAYER_B &&
      game.initialPlayer === CellState.A
    ) {
      setPlayer(undefined);
      setGameState(GameState.GAME_OF_LIFE);
    }
  }, [game, player, gameState, cells, setPlayer, setSelectedCellsCounter]);

  useEffect(() => {
    if (game === undefined) return;

    if (gameState === GameState.GAME_OF_LIFE) {
      const updateGameState = () => {
        game.grid.update();
        if (game.checkWin() != false) {
          setStatusText(`Player ${game.checkWin()} wins!`);
          setGameState(GameState.END);
          setPlayer(undefined);
          return;
        }

        setCells(game.getCellStates());
      };

      let x = 0;
      const interval = setInterval(function () {
        updateGameState();
        x++;
        if (x > nbIter) {
          clearInterval(interval);
          setCells(game.getCellStates());
          setPlayer(game.initialPlayer);
          setGameState(
            game.initialPlayer === CellState.A
              ? GameState.PLAYER_A
              : GameState.PLAYER_B
          );
        }
      }, 120);
    }
  }, [game, gameState]);

  return (
    <GameContext.Provider
      value={{
        size,
        gameState,
        player,
        cells,
        selectedCellsCounter,
        statusText,
        setPlayer,
        setSelectedCellsCounter,
        handleCellClick,
        handleValidation,
      }}
    >
      {children}
    </GameContext.Provider>
  );
};

export function useGameData() {
  const context = React.useContext(GameContext);

  if (context === undefined) {
    throw new Error("useWallet must be used within a WalletProvider");
  }

  return context;
}
```

---

src/utils.ts
```
import { CellState } from "./constants";

export function initBoardState(size: number): CellState[][] {
  const boardState = Array(size)
    .fill(undefined)
    .map((_, i) => {
      const row = Array(size)
        .fill(undefined)
        .map((_, j) => {
          //   if (i >= 2 && i <= 2 && j >= size / 2 && j < (size + 1) / 2) {
          //     return CellState.FORTRESS;
          //   }

          //   if (
          //     i >= size - 2 &&
          //     i <= size - 2 &&
          //     j >= size / 2 &&
          //     j < (size + 1) / 2
          //   ) {
          //     return CellState.FORTRESS;
          //   }
          return CellState.EMPTY;
        });

      return row;
    });

  return boardState;
}
```

---

src/constants.ts
```
export enum CellState {
  EMPTY = "empty",
  A = "a",
  B = "b",
}

export type Player = CellState.A | CellState.B;

export enum GameState {
  PLAYER_A = CellState.A,
  PLAYER_B = CellState.B,
  GAME_OF_LIFE = "gol",
  END = "end",
}

export type Position = {
  x: number;
  y: number;
};

export type Size = {
  width: number;
  height: number;
};

export type Fortress = {
  a: Position & Size;
  b: Position & Size;
};
```

---

src/app/page.tsx
```
"use client";

import Button from "@/components/Button";
import GridView from "../components/GridView";
import { useGameData } from "@/GameContext";
import { GameState } from "@/constants";

export default function Home() {
  const {
    size,
    gameState,
    cells,
    statusText,
    handleCellClick,
    handleValidation,
  } = useGameData();

  return (
    <div className="flex items-center justify-center h-screen">
      <div className="container mx-auto p-4">
        <h1 className="text-2xl mb-4">Competitive game of Life</h1>
        <p>{statusText}</p>
        <GridView size={size} cells={cells} onCellClick={handleCellClick} />
        {(gameState === GameState.PLAYER_A ||
          gameState === GameState.PLAYER_B) && (
          <Button
            variant="contained"
            color="primary"
            onClick={handleValidation}
          >
            Validate
          </Button>
        )}
      </div>
    </div>
  );
}
```

---

src/components/GridView.tsx
```
// Grid.tsx

import React from "react";

import Row from "./Row";
import { CellState } from "@/constants";

interface GridViewProps {
  size: number;
  cells: CellState[][] | undefined;

  onCellClick: (i: number, j: number) => boolean;
}

const GridView = ({ size, cells, onCellClick }: GridViewProps) => {
  if (!cells) return null;
  return (
    <div className={`grid grid-cols-${size} gap-0`}>
      {cells.map((row, rowIndex) => (
        <Row
          key={rowIndex}
          row={row}
          rowIndex={rowIndex}
          onCellClick={onCellClick}
        />
      ))}
    </div>
  );
};

export default GridView;
```

---

src/components/Row.tsx
```
// Row.tsx

import React from "react";
import Cell from "./Cell";

import { CellState } from "@/constants";
import { useGameData } from "@/GameContext";

interface RowProps {
  row: CellState[];
  rowIndex: number;

  onCellClick: (i: number, j: number) => boolean;
}

const Row = ({ row, rowIndex, onCellClick }: RowProps) => {
  const { player } = useGameData();

  const canInteract =
    (player === CellState.A && rowIndex < row.length / 2) ||
    (player === CellState.B && rowIndex >= row.length / 2);

  return (
    <div className="flex">
      {row.map((cell, cellIndex) => (
        <Cell
          key={cellIndex}
          state={cell}
          canInteract={canInteract}
          onClick={() => canInteract && onCellClick(rowIndex, cellIndex)}
        />
      ))}
    </div>
  );
};

export default Row;
```

---

src/components/Cell.tsx
```
import React, { useState } from "react";

import { CellState } from "@/constants";

interface CellProps {
  state: CellState;
  canInteract: boolean;
  onClick: () => boolean;
}

const Cell = ({ state, canInteract, onClick }: CellProps) => {
  const [showTooltip, setShowTooltip] = useState(false);

  // Required to ensure tailwindcss does not purge the classes
  let color = "";
  switch (state) {
    case CellState.A:
      color = "bg-cell-a";
      break;
    case CellState.B:
      color = "bg-cell-b";
      break;
    case CellState.EMPTY:
      color = "bg-cell-empty";
      break;
    default:
      break;
  }

  return (
    <div
      className={`w-4 h-4 border border-black ${color} ${
        canInteract
          ? "cursor-pointer hover:border-blue-500"
          : "cursor-not-allowed"
      }`}
      onClick={() => {
        const maximumReached = onClick();
        if (maximumReached) {
          setShowTooltip(true);
          setTimeout(() => setShowTooltip(false), 2000);
        }
      }}
    >
      {showTooltip && (
        <div className="absolute -top-8 left-1/2 transform -translate-x-1/2 w-48 p-2 bg-black text-white text-xs rounded">
          Maximum 3 squares can be selected. Unselect a square first.
        </div>
      )}
    </div>
  );
};

export default Cell;
```
------[]------
